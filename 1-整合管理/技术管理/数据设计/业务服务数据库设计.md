# 业务服务数据库设计

## 1. 数据库概述

### 1.1 数据库选择
- **主数据库**：MongoDB（文档型数据库，适合业务数据）
- **缓存数据库**：Redis（热点数据缓存）
- **消息队列**：RabbitMQ（异步任务和数据同步）
- **数据库名称**：`business_db`

### 1.2 设计原则
- **业务数据隔离**：业务服务拥有独立的数据库
- **数据一致性**：通过消息队列保证最终一致性
- **性能优化**：关键查询建立索引，热点数据缓存
- **扩展性**：支持数据量增长和分片

## 2. 数据模型设计

### 2.1 Prompt集合 (prompts)

#### 2.1.1 集合结构
```kotlin
// Kotlin实体类
data class Prompt(
    @Id val id: ObjectId? = null,
    val userId: ObjectId,                // 用户ID（来自用户服务）
    val title: String,                   // 标题
    val content: String,                 // 内容
    val description: String? = null,     // 描述
    val tags: List<String> = emptyList(), // 标签
    val category: String? = null,        // 分类名称（为了兼容保留）
    val categoryId: ObjectId? = null,    // 分类ID（关联Category集合）
    val folderId: ObjectId? = null,      // 文件夹ID（支持文件夹分类）
    val variables: List<String> = emptyList(), // 变量列表
    val useCount: Int = 0,               // 使用次数
    val isPublic: Boolean = false,       // 是否公开
    val isFavorite: Boolean = false,     // 是否收藏
    val isDeleted: Boolean = false,      // 是否删除
    val syncStatus: SyncStatus = SyncStatus.SYNCED, // 同步状态
    val createdAt: Instant = Instant.now(), // 创建时间
    val updatedAt: Instant = Instant.now(), // 更新时间
    val lastUsedAt: Instant? = null      // 最后使用时间
)

// 枚举定义
enum class SyncStatus {
    SYNCED,             // 已同步
    PENDING_CREATE,     // 待创建
    PENDING_UPDATE,     // 待更新
    PENDING_DELETE      // 待删除
}
```

#### 2.1.2 索引设计
```javascript
// 用户ID和更新时间索引（主要查询）
db.prompts.createIndex({ "userId": 1, "updatedAt": -1 })

// 用户ID和分类索引
db.prompts.createIndex({ "userId": 1, "category": 1 })
db.prompts.createIndex({ "userId": 1, "categoryId": 1 })

// 用户ID和收藏状态索引
db.prompts.createIndex({ "userId": 1, "isFavorite": 1 })

// 全文搜索索引
db.prompts.createIndex({ 
    "title": "text", 
    "content": "text", 
    "description": "text" 
})

// 标签索引
db.prompts.createIndex({ "tags": 1 })

// 同步状态索引
db.prompts.createIndex({ "syncStatus": 1 })

// 软删除索引
db.prompts.createIndex({ "isDeleted": 1 })
```

### 2.2 分类集合 (categories)

#### 2.2.1 集合结构
```kotlin
data class Category(
    @Id val id: ObjectId? = null,
    val userId: ObjectId,                // 用户ID
    val name: String,                    // 分类名称
    val color: String? = null,           // 分类颜色
    val sortOrder: Int = 0,              // 排序序号
    val isSystem: Boolean = false,       // 系统预置分类，不可删除
    val createdAt: Instant = Instant.now(), // 创建时间
    val updatedAt: Instant = Instant.now()  // 更新时间
)
```

#### 2.2.2 索引设计
```javascript
// 用户ID和排序序号索引
db.categories.createIndex({ "userId": 1, "sortOrder": 1 })

// 用户ID和名称索引（防止同名）
db.categories.createIndex({ "userId": 1, "name": 1 }, { unique: true })
```

### 2.3 标签集合 (tags)

#### 2.3.1 集合结构
```kotlin
data class Tag(
    @Id val id: ObjectId? = null,
    val userId: ObjectId,                // 用户ID
    val name: String,                    // 标签名称
    val color: String? = null,           // 标签颜色
    val useCount: Int = 0,               // 使用次数
    val createdAt: Instant = Instant.now(), // 创建时间
    val updatedAt: Instant = Instant.now()  // 更新时间
)
```

#### 2.2.2 索引设计
```javascript
// 用户ID和标签名称索引
db.tags.createIndex({ "userId": 1, "name": 1 }, { unique: true })

// 用户ID和使用次数索引
db.tags.createIndex({ "userId": 1, "useCount": -1 })

// 标签名称索引（用于搜索）
db.tags.createIndex({ "name": "text" })
```

### 2.3 同步记录集合 (sync_records)

#### 2.3.1 集合结构
```kotlin
data class SyncRecord(
    @Id val id: ObjectId? = null,
    val userId: ObjectId,                // 用户ID
    val deviceId: String,                // 设备标识
    val deviceType: DeviceType,          // 设备类型
    val lastSyncTime: Instant = Instant.now(), // 最后同步时间
    val syncVersion: Long = 0,           // 同步版本号
    val pendingChanges: Int = 0,         // 待同步变更数
    val syncStatus: SyncRecordStatus = SyncRecordStatus.SUCCESS // 同步状态
)

enum class DeviceType {
    WEB,            // Web端
    ANDROID,        // Android端
    IOS             // iOS端
}

enum class SyncRecordStatus {
    SUCCESS,        // 成功
    FAILED,         // 失败
    IN_PROGRESS     // 进行中
}
```

#### 2.3.2 索引设计
```javascript
// 用户ID和设备ID索引
db.sync_records.createIndex({ "userId": 1, "deviceId": 1 }, { unique: true })

// 用户ID和最后同步时间索引
db.sync_records.createIndex({ "userId": 1, "lastSyncTime": -1 })

// 同步状态索引
db.sync_records.createIndex({ "syncStatus": 1 })
```

### 2.4 文件夹集合 (folders)

#### 2.4.1 集合结构
```kotlin
data class Folder(
    @Id val id: ObjectId? = null,
    val userId: ObjectId,                // 用户ID
    val name: String,                    // 文件夹名称
    val parentId: ObjectId? = null,      // 父文件夹ID（支持多级文件夹）
    val order: Int = 0,                  // 排序序号
    val color: String? = null,           // 文件夹颜色
    val icon: String? = null,            // 文件夹图标
    val description: String? = null,     // 文件夹描述
    val promptCount: Int = 0,            // 包含的prompt数量
    val isDeleted: Boolean = false,      // 是否删除
    val syncStatus: SyncStatus = SyncStatus.SYNCED, // 同步状态
    val createdAt: Instant = Instant.now(), // 创建时间
    val updatedAt: Instant = Instant.now()  // 更新时间
)
```

#### 2.4.2 索引设计
```javascript
// 用户ID和父文件夹ID索引
db.folders.createIndex({ "userId": 1, "parentId": 1 })

// 用户ID和排序序号索引
db.folders.createIndex({ "userId": 1, "order": 1 })

// 用户ID和名称索引
db.folders.createIndex({ "userId": 1, "name": 1 })

// 同步状态索引
db.folders.createIndex({ "syncStatus": 1 })

// 软删除索引
db.folders.createIndex({ "isDeleted": 1 })
```

### 2.5 分享集合 (shares)

#### 2.5.1 集合结构
```kotlin
data class Share(
    @Id val id: ObjectId? = null,
    val userId: ObjectId,                // 用户ID
    val promptId: ObjectId,              // Prompt ID
    val shareToken: String,              // 分享令牌（唯一）
    val accessCount: Int = 0,            // 访问次数
    val expiresAt: Instant? = null,      // 过期时间
    val isActive: Boolean = true,        // 是否有效
    val createdAt: Instant = Instant.now(), // 创建时间
    val updatedAt: Instant = Instant.now()  // 更新时间
)
```

#### 2.5.2 索引设计
```javascript
// 分享令牌索引（唯一）
db.shares.createIndex({ "shareToken": 1 }, { unique: true })

// 用户ID和创建时间索引
db.shares.createIndex({ "userId": 1, "createdAt": -1 })

// Prompt ID索引
db.shares.createIndex({ "promptId": 1 })

// TTL索引：自动清理过期分享
db.shares.createIndex({ "expiresAt": 1 }, { expireAfterSeconds: 0 })

// 活跃状态索引
db.shares.createIndex({ "isActive": 1 })
```

### 2.6 反馈集合 (feedbacks)

#### 2.6.1 集合结构
```kotlin
data class Feedback(
    @Id val id: ObjectId? = null,
    val userId: ObjectId,                // 用户ID
    val type: String,                    // 反馈类型 (bug, suggestion, other)
    val content: String,                 // 反馈内容
    val contact: String? = null,         // 联系方式
    val status: String = "PENDING",      // 状态 (PENDING, PROCESSED)
    val createdAt: Instant = Instant.now() // 创建时间
)
```

#### 2.6.2 索引设计
```javascript
// 用户ID索引
db.feedbacks.createIndex({ "userId": 1 })

// 状态索引
db.feedbacks.createIndex({ "status": 1 })

// 类型索引
db.feedbacks.createIndex({ "type": 1 })
```

## 3. Redis缓存设计

### 3.1 缓存键设计
```kotlin
// Prompt缓存
val PROMPT_CACHE_KEY = "prompt:${promptId}"

// 用户Prompt列表缓存
val USER_PROMPTS_CACHE_KEY = "user_prompts:${userId}:${page}"

// 热门Prompt缓存
val POPULAR_PROMPTS_KEY = "popular_prompts"

// 标签缓存
val TAGS_CACHE_KEY = "tags:${userId}"

// 分享内容缓存
val SHARE_CACHE_KEY = "share:${shareToken}"
```

### 3.2 缓存配置
```yaml
# Redis配置
spring:
  redis:
    host: localhost
    port: 6379
    timeout: 2000ms

# 缓存配置
cache:
  prompt:
    ttl: 1h          # Prompt缓存1小时
  user-prompts:
    ttl: 30m         # 用户Prompt列表缓存30分钟
  popular-prompts:
    ttl: 2h          # 热门Prompt缓存2小时
  tags:
    ttl: 1h          # 标签缓存1小时
  share:
    ttl: 24h         # 分享内容缓存24小时
```

## 4. 消息队列设计

### 4.1 队列配置
```kotlin
// 用户事件队列
const val USER_EVENTS_EXCHANGE = "user.events.exchange"
const val USER_REGISTERED_QUEUE = "user.registered.queue"
const val USER_UPDATED_QUEUE = "user.updated.queue"

// 同步事件队列
const val SYNC_EVENTS_EXCHANGE = "sync.events.exchange"
const val SYNC_REQUEST_QUEUE = "sync.request.queue"
const val SYNC_COMPLETE_QUEUE = "sync.complete.queue"

// 分享事件队列
const val SHARE_EVENTS_EXCHANGE = "share.events.exchange"
const val SHARE_CREATED_QUEUE = "share.created.queue"
const val SHARE_ACCESSED_QUEUE = "share.accessed.queue"
```

### 4.2 消息格式
```kotlin
// 用户注册事件
data class UserRegisteredEvent(
    val eventId: String = UUID.randomUUID().toString(),
    val eventType: String = "USER_REGISTERED",
    val userId: String,
    val email: String,
    val username: String?,
    val timestamp: Instant = Instant.now()
)

// Prompt创建事件
data class PromptCreatedEvent(
    val eventId: String = UUID.randomUUID().toString(),
    val eventType: String = "PROMPT_CREATED",
    val promptId: String,
    val userId: String,
    val title: String,
    val timestamp: Instant = Instant.now()
)

// 同步请求事件
data class SyncRequestEvent(
    val eventId: String = UUID.randomUUID().toString(),
    val eventType: String = "SYNC_REQUEST",
    val userId: String,
    val deviceId: String,
    val syncVersion: Long,
    val timestamp: Instant = Instant.now()
)
```

## 5. 数据同步策略

### 5.1 增量同步机制
```kotlin
// 增量同步请求
data class IncrementalSyncRequest(
    val userId: String,
    val deviceId: String,
    val lastSyncTime: Instant,
    val syncVersion: Long,
    val changes: List<ChangeRecord> = emptyList()
)

// 变更记录
data class ChangeRecord(
    val type: ChangeType,                // 变更类型
    val resource: ResourceType,          // 资源类型
    val id: String,                      // 资源ID
    val data: Map<String, Any>? = null,  // 资源数据
    val timestamp: Instant               // 变更时间
)

enum class ChangeType {
    CREATE,         // 创建
    UPDATE,         // 更新
    DELETE          // 删除
}

enum class ResourceType {
    PROMPT,         // Prompt
    TAG             // 标签
}
```

### 5.2 冲突解决策略
```kotlin
// 冲突解决策略
class ConflictResolver {
    
    fun resolvePromptConflict(
        localPrompt: Prompt,
        remotePrompt: Prompt
    ): Prompt {
        // 最后修改优先策略
        return if (localPrompt.updatedAt.isAfter(remotePrompt.updatedAt)) {
            localPrompt
        } else {
            remotePrompt
        }
    }
    
    fun resolveTagConflict(
        localTag: Tag,
        remoteTag: Tag
    ): Tag {
        // 使用次数优先策略
        return if (localTag.useCount > remoteTag.useCount) {
            localTag
        } else {
            remoteTag
        }
    }
}
```

## 6. 数据安全

### 6.1 数据访问控制
```kotlin
// 数据访问权限检查
suspend fun checkPromptAccess(userId: ObjectId, promptId: ObjectId) {
    val prompt = promptRepository.findById(promptId)
    if (prompt?.userId != userId && !prompt.isPublic) {
        throw AccessDeniedException("无权访问该Prompt")
    }
}

// 分享访问检查
suspend fun checkShareAccess(shareToken: String): Share {
    val share = shareRepository.findByToken(shareToken)
    if (share == null || !share.isActive || share.isExpired()) {
        throw AccessDeniedException("分享链接无效或已过期")
    }
    return share
}
```

### 6.2 数据备份策略
```yaml
# MongoDB备份配置
backup:
  schedule: "0 2 * * *"        # 每天凌晨2点备份
  retention: 7                  # 保留7天备份
  storage: "s3://backups"       # 备份存储位置

# Redis备份配置
redis:
  backup:
    enabled: true
    schedule: "0 */6 * * *"     # 每6小时备份一次
```

---
**文档版本**：1.0  
**编制人**：项目经理  
**编制日期**：第1周  
**下次评审**：业务服务数据库实现阶段开始前
